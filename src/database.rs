use diesel::{
    r2d2::{ConnectionManager, Pool, PooledConnection},
    PgConnection,
};

use crate::sql_types::{ApiKey, ApiKeyState};

use rocket::{
    http::Status,
    request::{self, FromRequest},
    Outcome, Request, State,
};
use std::{error::Error, fs::File, io::Write, ops::Deref, path::Path};

const DEFAULT_USERNAME: &str = "badmin";

struct DatabaseError {
    pub message: String,
}

impl<E: Error> From<E> for DatabaseError {
    fn from(err: E) -> Self {
        DatabaseError {
            message: format!("{:?}", err),
        }
    }
}

/// Our connection pool type
pub type PostgresPool = Pool<ConnectionManager<PgConnection>>;

pub struct Connection(pub PooledConnection<ConnectionManager<PgConnection>>);

fn setup_database(connection: &PgConnection) -> Result<(), DatabaseError> {
    let master_keys = crate::sql_types::ApiKey::count_master_keys(connection)?;

    // Generate a default API key and save it to disk
    if master_keys == 0 {
        let user = DEFAULT_USERNAME.to_string();
        let file = format!("{}.apikey", user);
        let key = ApiKey::new(
            &user,
            ApiKeyState::Admin,
            Some("Autogenerated admin account".to_string()),
        );
        key.persist(&connection)?;
        let path = Path::new(&file);
        let mut fd = File::create(path)?;
        fd.write_all(key.key.as_bytes())?;
    }

    Ok(())
}

/// Initialize the connection pool
pub fn connect() -> PostgresPool {
    // TODO: Example for a connection URL here (?)
    let url =
        dotenv::var("DATABASE_URL").expect("Please set the DATABASE_URL environment variable!");
    let manager = ConnectionManager::<PgConnection>::new(url);
    let pool = Pool::new(manager)
        .expect("Failed to connect to the database. Please check the connection string!");

    if let Ok(connection) = pool.get() {
        setup_database(&connection)
            .map_err(|e| format!("Failed to setup default values! Error: {}", e.message))
            .unwrap();
    }

    pool
}

impl<'a, 'r> FromRequest<'a, 'r> for Connection {
    type Error = ();

    /// Inject our database connection into every request.
    fn from_request(request: &'a Request<'r>) -> request::Outcome<Connection, Self::Error> {
        let pool = request.guard::<State<PostgresPool>>()?;

        match pool.get() {
            Ok(conn) => Outcome::Success(Connection(conn)),
            Err(_) => Outcome::Failure((Status::ServiceUnavailable, ())),
        }
    }
}

impl Deref for Connection {
    type Target = PgConnection;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
